"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[747],{8076:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"The-Digital-Twin/Sim-to-Real-Transfer/sim-to-real-transfer","title":"Sim-to-Real Transfer","description":"Introduction","source":"@site/docs/03-The-Digital-Twin/06-Sim-to-Real-Transfer/index.md","sourceDirName":"03-The-Digital-Twin/06-Sim-to-Real-Transfer","slug":"/module-03/sim-to-real-transfer","permalink":"/physical-ai-hackathon/docs/module-03/sim-to-real-transfer","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-The-Digital-Twin/06-Sim-to-Real-Transfer/index.md","tags":[],"version":"current","frontMatter":{"id":"sim-to-real-transfer","title":"Sim-to-Real Transfer","slug":"/module-03/sim-to-real-transfer"},"sidebar":"tutorialSidebar","previous":{"title":"Domain Randomization Techniques","permalink":"/physical-ai-hackathon/docs/module-03/domain-randomization"},"next":{"title":"The AI-Robot Brain (NVIDIA Isaac\u2122)","permalink":"/physical-ai-hackathon/docs/module-04"}}');var s=r(4848),t=r(8453);const a={id:"sim-to-real-transfer",title:"Sim-to-Real Transfer",slug:"/module-03/sim-to-real-transfer"},l="Sim-to-Real Transfer",o={},d=[{value:"Introduction",id:"introduction",level:2},{value:"The Reality Gap",id:"the-reality-gap",level:2},{value:"Common Sources of Reality Gap",id:"common-sources-of-reality-gap",level:3},{value:"Strategy 1: Domain Randomization",id:"strategy-1-domain-randomization",level:2},{value:"Concept",id:"concept",level:3},{value:"Implementation in Gazebo",id:"implementation-in-gazebo",level:3},{value:"What to Randomize",id:"what-to-randomize",level:3},{value:"Strategy 2: System Identification",id:"strategy-2-system-identification",level:2},{value:"Concept",id:"concept-1",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Strategy 3: Progressive Transfer",id:"strategy-3-progressive-transfer",level:2},{value:"Concept",id:"concept-2",level:3},{value:"Implementation Pipeline",id:"implementation-pipeline",level:3},{value:"Strategy 4: Residual Learning",id:"strategy-4-residual-learning",level:2},{value:"Concept",id:"concept-3",level:3},{value:"Validation Strategies",id:"validation-strategies",level:2},{value:"1. Staged Validation",id:"1-staged-validation",level:3},{value:"2. Safety Checks",id:"2-safety-checks",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 DO:",id:"-do",level:3},{value:"\u274c DON&#39;T:",id:"-dont",level:3},{value:"Case Study: Humanoid Walking Transfer",id:"case-study-humanoid-walking-transfer",level:2},{value:"Problem",id:"problem",level:3},{value:"Solution Process",id:"solution-process",level:3},{value:"Tools and Frameworks",id:"tools-and-frameworks",level:2},{value:"Isaac Sim Domain Randomization",id:"isaac-sim-domain-randomization",level:3},{value:"Gazebo System Identification",id:"gazebo-system-identification",level:3},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sim-to-real-transfer",children:"Sim-to-Real Transfer"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sim-to-Real Transfer"})," is the process of deploying robot controllers trained in simulation to real hardware. This is one of the most critical challenges in Physical AI - bridging the ",(0,s.jsx)(n.strong,{children:"reality gap"})," between perfect simulations and the messy real world. This chapter covers techniques to minimize this gap and successfully transfer learned behaviors."]}),"\n",(0,s.jsx)(n.h2,{id:"the-reality-gap",children:"The Reality Gap"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:'graph LR\r\n    subgraph "Simulation"\r\n        S1[Perfect Physics]\r\n        S2[No Noise]\r\n        S3[Infinite Resets]\r\n        S4[Fast Execution]\r\n    end\r\n    \r\n    subgraph "Reality Gap"\r\n        GAP[Differences]\r\n    end\r\n    \r\n    subgraph "Real World"\r\n        R1[Imperfect Physics]\r\n        R2[Sensor Noise]\r\n        R3[Hardware Limits]\r\n        R4[Real-time Constraints]\r\n    end\r\n    \r\n    S1 -.-> GAP\r\n    S2 -.-> GAP\r\n    S3 -.-> GAP\r\n    S4 -.-> GAP\r\n    GAP -.-> R1\r\n    GAP -.-> R2\r\n    GAP -.-> R3\r\n    GAP -.-> R4\n'})}),"\n",(0,s.jsx)(n.h3,{id:"common-sources-of-reality-gap",children:"Common Sources of Reality Gap"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"Simulation"}),(0,s.jsx)(n.th,{children:"Reality"}),(0,s.jsx)(n.th,{children:"Impact"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Physics"})}),(0,s.jsx)(n.td,{children:"Simplified models"}),(0,s.jsx)(n.td,{children:"Complex dynamics"}),(0,s.jsx)(n.td,{children:"High"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Sensors"})}),(0,s.jsx)(n.td,{children:"Perfect data"}),(0,s.jsx)(n.td,{children:"Noisy, delayed"}),(0,s.jsx)(n.td,{children:"High"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Actuators"})}),(0,s.jsx)(n.td,{children:"Instant response"}),(0,s.jsx)(n.td,{children:"Delays, backlash"}),(0,s.jsx)(n.td,{children:"Medium"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Environment"})}),(0,s.jsx)(n.td,{children:"Controlled"}),(0,s.jsx)(n.td,{children:"Variable"}),(0,s.jsx)(n.td,{children:"Medium"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Timing"})}),(0,s.jsx)(n.td,{children:"Flexible"}),(0,s.jsx)(n.td,{children:"Real-time"}),(0,s.jsx)(n.td,{children:"High"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"strategy-1-domain-randomization",children:"Strategy 1: Domain Randomization"}),"\n",(0,s.jsx)(n.h3,{id:"concept",children:"Concept"}),"\n",(0,s.jsx)(n.p,{children:"Randomize simulation parameters during training so the policy learns to be robust to variations."}),"\n",(0,s.jsx)(n.h3,{id:"implementation-in-gazebo",children:"Implementation in Gazebo"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nDomain randomization for Gazebo simulation\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom gazebo_msgs.srv import SetPhysicsProperties, SetModelState\r\nfrom geometry_msgs.msg import Vector3\r\nimport random\r\n\r\nclass DomainRandomizer(Node):\r\n    """\r\n    Randomizes physics and environment parameters in Gazebo.\r\n    """\r\n    \r\n    def __init__(self):\r\n        super().__init__(\'domain_randomizer\')\r\n        \r\n        # Service clients\r\n        self.physics_client = self.create_client(\r\n            SetPhysicsProperties,\r\n            \'/gazebo/set_physics_properties\'\r\n        )\r\n        \r\n        # Randomization parameters\r\n        self.gravity_range = (9.5, 10.0)  # m/s\xb2\r\n        self.friction_range = (0.5, 1.5)\r\n        self.mass_scale_range = (0.9, 1.1)\r\n        \r\n        # Randomize every episode\r\n        self.create_timer(30.0, self.randomize_environment)\r\n        \r\n        self.get_logger().info(\'Domain Randomizer initialized\')\r\n    \r\n    def randomize_environment(self):\r\n        """Randomize simulation parameters"""\r\n        # 1. Randomize gravity\r\n        gravity = random.uniform(*self.gravity_range)\r\n        self.set_gravity(gravity)\r\n        \r\n        # 2. Randomize friction\r\n        friction = random.uniform(*self.friction_range)\r\n        self.set_friction(friction)\r\n        \r\n        # 3. Randomize robot mass\r\n        mass_scale = random.uniform(*self.mass_scale_range)\r\n        self.scale_robot_mass(mass_scale)\r\n        \r\n        # 4. Randomize lighting (visual randomization)\r\n        self.randomize_lighting()\r\n        \r\n        self.get_logger().info(\r\n            f\'Randomized: gravity={gravity:.2f}, \'\r\n            f\'friction={friction:.2f}, mass_scale={mass_scale:.2f}\'\r\n        )\r\n    \r\n    def set_gravity(self, gravity_z):\r\n        """Set gravity in simulation"""\r\n        request = SetPhysicsProperties.Request()\r\n        request.gravity = Vector3(x=0.0, y=0.0, z=-gravity_z)\r\n        \r\n        future = self.physics_client.call_async(request)\r\n        # Handle response...\r\n    \r\n    def set_friction(self, friction):\r\n        """Set surface friction coefficients"""\r\n        # Implementation depends on Gazebo version\r\n        pass\r\n    \r\n    def scale_robot_mass(self, scale):\r\n        """Scale robot link masses"""\r\n        # Implementation: modify URDF inertial properties\r\n        pass\r\n    \r\n    def randomize_lighting(self):\r\n        """Randomize lighting conditions"""\r\n        # Change ambient light, shadows, etc.\r\n        pass\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    randomizer = DomainRandomizer()\r\n    rclpy.spin(randomizer)\r\n    randomizer.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"what-to-randomize",children:"What to Randomize"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Physics Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gravity (\xb15%)"}),"\n",(0,s.jsx)(n.li,{children:"Friction coefficients (\xb150%)"}),"\n",(0,s.jsx)(n.li,{children:"Link masses (\xb110%)"}),"\n",(0,s.jsx)(n.li,{children:"Joint damping (\xb130%)"}),"\n",(0,s.jsx)(n.li,{children:"Contact parameters"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Visual Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lighting intensity and direction"}),"\n",(0,s.jsx)(n.li,{children:"Textures and colors"}),"\n",(0,s.jsx)(n.li,{children:"Camera exposure and gain"}),"\n",(0,s.jsx)(n.li,{children:"Background scenes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Sensor Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Gaussian noise on measurements"}),"\n",(0,s.jsx)(n.li,{children:"Sensor delays (0-50ms)"}),"\n",(0,s.jsx)(n.li,{children:"Dropout/missing data"}),"\n",(0,s.jsx)(n.li,{children:"Calibration offsets"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"strategy-2-system-identification",children:"Strategy 2: System Identification"}),"\n",(0,s.jsx)(n.h3,{id:"concept-1",children:"Concept"}),"\n",(0,s.jsx)(n.p,{children:"Measure real robot parameters and update simulation to match reality."}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nSystem identification for sim-to-real transfer\r\n"""\r\n\r\nimport numpy as np\r\nfrom scipy.optimize import minimize\r\nimport rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass SystemIdentifier(Node):\r\n    """\r\n    Identifies real robot parameters by comparing\r\n    simulation predictions with real measurements.\r\n    """\r\n    \r\n    def __init__(self):\r\n        super().__init__(\'system_identifier\')\r\n        \r\n        # Collect real robot data\r\n        self.real_trajectories = []\r\n        self.sim_trajectories = []\r\n        \r\n        self.get_logger().info(\'System Identifier initialized\')\r\n    \r\n    def identify_parameters(self):\r\n        """\r\n        Optimize simulation parameters to match real data.\r\n        """\r\n        # Initial parameter guess\r\n        initial_params = {\r\n            \'link_mass\': 1.5,\r\n            \'joint_damping\': 0.5,\r\n            \'friction_coef\': 0.8\r\n        }\r\n        \r\n        # Optimization\r\n        result = minimize(\r\n            self.objective_function,\r\n            x0=list(initial_params.values()),\r\n            method=\'Nelder-Mead\',\r\n            options={\'maxiter\': 100}\r\n        )\r\n        \r\n        # Extract optimized parameters\r\n        optimized_params = {\r\n            \'link_mass\': result.x[0],\r\n            \'joint_damping\': result.x[1],\r\n            \'friction_coef\': result.x[2]\r\n        }\r\n        \r\n        self.get_logger().info(f\'Identified parameters: {optimized_params}\')\r\n        return optimized_params\r\n    \r\n    def objective_function(self, params):\r\n        """\r\n        Objective: minimize difference between sim and real.\r\n        \r\n        Args:\r\n            params: [link_mass, joint_damping, friction_coef]\r\n            \r\n        Returns:\r\n            float: Error metric\r\n        """\r\n        # Run simulation with these parameters\r\n        sim_traj = self.run_simulation(params)\r\n        \r\n        # Compare with real trajectory\r\n        error = np.mean((sim_traj - self.real_trajectories[0])**2)\r\n        \r\n        return error\r\n    \r\n    def run_simulation(self, params):\r\n        """Run simulation with given parameters"""\r\n        # Update simulation parameters\r\n        # Run trajectory\r\n        # Return simulated trajectory\r\n        pass\r\n    \r\n    def collect_real_data(self):\r\n        """Collect trajectory data from real robot"""\r\n        # Execute predefined trajectory on real robot\r\n        # Record joint positions, velocities, torques\r\n        pass\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    identifier = SystemIdentifier()\r\n    \r\n    # Collect data\r\n    identifier.collect_real_data()\r\n    \r\n    # Identify parameters\r\n    params = identifier.identify_parameters()\r\n    \r\n    identifier.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"strategy-3-progressive-transfer",children:"Strategy 3: Progressive Transfer"}),"\n",(0,s.jsx)(n.h3,{id:"concept-2",children:"Concept"}),"\n",(0,s.jsx)(n.p,{children:"Gradually transition from simulation to reality through intermediate steps."}),"\n",(0,s.jsx)(n.h3,{id:"implementation-pipeline",children:"Implementation Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph LR\r\n    A[Pure Simulation] --\x3e B[Sim + Noise]\r\n    B --\x3e C[Sim + Real Sensors]\r\n    C --\x3e D[Real Robot + Sim Feedback]\r\n    D --\x3e E[Pure Real Robot]\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Step 1:"})," Train in perfect simulation\r\n",(0,s.jsx)(n.strong,{children:"Step 2:"})," Add realistic noise and delays\r\n",(0,s.jsx)(n.strong,{children:"Step 3:"})," Use real sensor data with simulated actuators\r\n",(0,s.jsx)(n.strong,{children:"Step 4:"})," Use real robot with simulation safety net\r\n",(0,s.jsx)(n.strong,{children:"Step 5:"})," Deploy fully on real robot"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"strategy-4-residual-learning",children:"Strategy 4: Residual Learning"}),"\n",(0,s.jsx)(n.h3,{id:"concept-3",children:"Concept"}),"\n",(0,s.jsx)(n.p,{children:"Learn a correction policy that adapts simulation-trained policy to reality."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ResidualPolicy:\r\n    """\r\n    Combines simulation-trained policy with learned residual.\r\n    """\r\n    \r\n    def __init__(self, sim_policy, residual_policy):\r\n        self.sim_policy = sim_policy\r\n        self.residual_policy = residual_policy\r\n    \r\n    def get_action(self, observation):\r\n        # Get base action from simulation policy\r\n        base_action = self.sim_policy(observation)\r\n        \r\n        # Get correction from residual policy\r\n        residual = self.residual_policy(observation)\r\n        \r\n        # Combine\r\n        final_action = base_action + residual\r\n        \r\n        return final_action\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Training:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Train base policy in simulation"}),"\n",(0,s.jsx)(n.li,{children:"Deploy to real robot and collect data"}),"\n",(0,s.jsx)(n.li,{children:"Train residual policy to correct errors"}),"\n",(0,s.jsx)(n.li,{children:"Iterate"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"validation-strategies",children:"Validation Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"1-staged-validation",children:"1. Staged Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class SimToRealValidator:\r\n    """\r\n    Validates sim-to-real transfer in stages.\r\n    """\r\n    \r\n    def validate_stage_1_kinematics(self):\r\n        """Test if robot reaches commanded positions"""\r\n        test_positions = self.generate_test_positions()\r\n        \r\n        for pos in test_positions:\r\n            sim_result = self.simulate_motion(pos)\r\n            real_result = self.execute_real_motion(pos)\r\n            \r\n            error = np.linalg.norm(sim_result - real_result)\r\n            \r\n            if error > self.threshold:\r\n                self.log_error(f\'Kinematic error: {error}\')\r\n                return False\r\n        \r\n        return True\r\n    \r\n    def validate_stage_2_dynamics(self):\r\n        """Test if robot follows dynamic trajectories"""\r\n        # Test with varying speeds and accelerations\r\n        pass\r\n    \r\n    def validate_stage_3_task(self):\r\n        """Test if robot completes actual task"""\r\n        # Execute full task and measure success rate\r\n        pass\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-safety-checks",children:"2. Safety Checks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class SafetyMonitor:\r\n    """\r\n    Monitors robot during sim-to-real transfer.\r\n    """\r\n    \r\n    def __init__(self):\r\n        self.joint_limits = self.load_joint_limits()\r\n        self.torque_limits = self.load_torque_limits()\r\n        self.emergency_stop = False\r\n    \r\n    def check_safety(self, state, action):\r\n        """\r\n        Check if action is safe to execute.\r\n        \r\n        Returns:\r\n            bool: True if safe, False otherwise\r\n        """\r\n        # Check joint limits\r\n        if not self.check_joint_limits(state.positions):\r\n            self.get_logger().error(\'Joint limit violation!\')\r\n            return False\r\n        \r\n        # Check torque limits\r\n        if not self.check_torque_limits(action):\r\n            self.get_logger().error(\'Torque limit violation!\')\r\n            return False\r\n        \r\n        # Check stability (e.g., IMU readings)\r\n        if not self.check_stability(state.imu):\r\n            self.get_logger().error(\'Unstable state detected!\')\r\n            return False\r\n        \r\n        return True\r\n    \r\n    def emergency_stop_robot(self):\r\n        """Immediately stop all robot motion"""\r\n        self.emergency_stop = True\r\n        # Send zero torque commands\r\n        # Engage brakes if available\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"-do",children:"\u2705 DO:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Start Simple"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test basic movements first"}),"\n",(0,s.jsx)(n.li,{children:"Gradually increase complexity"}),"\n",(0,s.jsx)(n.li,{children:"Validate each stage"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Domain Randomization"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Randomize physics parameters"}),"\n",(0,s.jsx)(n.li,{children:"Add sensor noise"}),"\n",(0,s.jsx)(n.li,{children:"Vary environmental conditions"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Implement Safety Checks"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Joint limit monitoring"}),"\n",(0,s.jsx)(n.li,{children:"Torque limiting"}),"\n",(0,s.jsx)(n.li,{children:"Emergency stop capability"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Collect Real Data"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Record all real robot experiments"}),"\n",(0,s.jsx)(n.li,{children:"Use for system identification"}),"\n",(0,s.jsx)(n.li,{children:"Build dataset for residual learning"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Iterate"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sim-to-real is iterative"}),"\n",(0,s.jsx)(n.li,{children:"Update simulation based on real data"}),"\n",(0,s.jsx)(n.li,{children:"Retrain policies with better sim"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-dont",children:"\u274c DON'T:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Don't Skip Validation"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always validate in stages"}),"\n",(0,s.jsx)(n.li,{children:"Don't deploy untested policies"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Don't Ignore Differences"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Document all sim-real discrepancies"}),"\n",(0,s.jsx)(n.li,{children:"Update simulation accordingly"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Don't Rush"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sim-to-real takes time"}),"\n",(0,s.jsx)(n.li,{children:"Safety is paramount"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"case-study-humanoid-walking-transfer",children:"Case Study: Humanoid Walking Transfer"}),"\n",(0,s.jsx)(n.h3,{id:"problem",children:"Problem"}),"\n",(0,s.jsx)(n.p,{children:"Policy trained in Isaac Sim for bipedal walking fails on real Unitree G1."}),"\n",(0,s.jsx)(n.h3,{id:"solution-process",children:"Solution Process"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Identify Discrepancies"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Compare simulation vs reality\r\nsim_step_height = 0.15  # m\r\nreal_step_height = 0.08  # m  <- Significant difference!\r\n\r\nsim_step_time = 0.5  # s\r\nreal_step_time = 0.7  # s  <- Slower in reality\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Update Simulation"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Increase joint damping (0.5 \u2192 1.2)"}),"\n",(0,s.jsx)(n.li,{children:"Add actuator delays (0ms \u2192 20ms)"}),"\n",(0,s.jsx)(n.li,{children:"Reduce max joint velocities"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Retrain with Randomization"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Add randomization ranges\r\njoint_damping: [0.8, 1.5]\r\nactuator_delay: [10ms, 30ms]\r\nground_friction: [0.6, 1.2]\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"4. Progressive Deployment"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Stage 1: Standing balance \u2713"}),"\n",(0,s.jsx)(n.li,{children:"Stage 2: Weight shifting \u2713"}),"\n",(0,s.jsx)(n.li,{children:"Stage 3: Single steps \u2713"}),"\n",(0,s.jsx)(n.li,{children:"Stage 4: Continuous walking \u2713"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result:"})," 85% success rate on real robot (vs 95% in sim)"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tools-and-frameworks",children:"Tools and Frameworks"}),"\n",(0,s.jsx)(n.h3,{id:"isaac-sim-domain-randomization",children:"Isaac Sim Domain Randomization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from omni.isaac.core.utils.extensions import enable_extension\r\nenable_extension("omni.isaac.dr")\r\n\r\nfrom omni.isaac.dr import DomainRandomization\r\n\r\ndr = DomainRandomization()\r\ndr.randomize_physics_material(\r\n    prim_path="/World/Ground",\r\n    friction_range=(0.5, 1.5),\r\n    restitution_range=(0.0, 0.3)\r\n)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"gazebo-system-identification",children:"Gazebo System Identification"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Record bag file of real robot\r\nros2 bag record /joint_states /imu/data\r\n\r\n# Replay in simulation and compare\r\nros2 bag play real_robot.bag\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sim-to-real transfer bridges simulation and reality"}),"\n",(0,s.jsx)(n.li,{children:"Domain randomization increases policy robustness"}),"\n",(0,s.jsx)(n.li,{children:"System identification matches sim to real parameters"}),"\n",(0,s.jsx)(n.li,{children:"Progressive transfer reduces risk"}),"\n",(0,s.jsx)(n.li,{children:"Validation and safety are critical"}),"\n",(0,s.jsx)(n.li,{children:"Iteration is key to success"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Successful sim-to-real transfer enables rapid development in simulation while deploying to real robots safely and effectively."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://arxiv.org/abs/1703.06907",children:"Sim-to-Real Transfer in Deep RL"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://arxiv.org/abs/1703.06907",children:"Domain Randomization for Transferring Deep Neural Networks"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://arxiv.org/abs/1808.00177",children:"Learning Dexterous In-Hand Manipulation"})," (OpenAI)"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.omniverse.nvidia.com/isaacsim/latest/features/domain_randomization.html",children:"Isaac Sim Domain Randomization"})}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);