"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[9108],{17:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"The-Digital-Twin/Physics-Simulation/physics-simulation-fundamentals","title":"Physics Simulation Fundamentals","description":"Introduction","source":"@site/docs/03-The-Digital-Twin/04-Physics-Simulation/index.md","sourceDirName":"03-The-Digital-Twin/04-Physics-Simulation","slug":"/module-03/physics-simulation-fundamentals","permalink":"/physical-ai-hackathon/docs/module-03/physics-simulation-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-The-Digital-Twin/04-Physics-Simulation/index.md","tags":[],"version":"current","frontMatter":{"id":"physics-simulation-fundamentals","title":"Physics Simulation Fundamentals","slug":"/module-03/physics-simulation-fundamentals"},"sidebar":"tutorialSidebar","previous":{"title":"URDF and SDF Robot Description (In-Depth)","permalink":"/physical-ai-hackathon/docs/module-03/urdf-sdf-deep-dive"},"next":{"title":"Domain Randomization Techniques","permalink":"/physical-ai-hackathon/docs/module-03/domain-randomization"}}');var s=r(4848),t=r(8453);const o={id:"physics-simulation-fundamentals",title:"Physics Simulation Fundamentals",slug:"/module-03/physics-simulation-fundamentals"},l="Physics Simulation Fundamentals",c={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Physics Engine Overview",id:"physics-engine-overview",level:2},{value:"Core Physics Concepts",id:"core-physics-concepts",level:2},{value:"1. Rigid Body Dynamics",id:"1-rigid-body-dynamics",level:3},{value:"2. Collision Detection",id:"2-collision-detection",level:3},{value:"3. Contact Dynamics",id:"3-contact-dynamics",level:3},{value:"4. Numerical Integration",id:"4-numerical-integration",level:3},{value:"Tuning Physics for Stability",id:"tuning-physics-for-stability",level:2},{value:"Problem: Robot Falls Through Floor",id:"problem-robot-falls-through-floor",level:3},{value:"Problem: Simulation Too Slow",id:"problem-simulation-too-slow",level:3},{value:"Problem: Robot Unstable/Jittery",id:"problem-robot-unstablejittery",level:3},{value:"Physics Engine Comparison",id:"physics-engine-comparison",level:2},{value:"Advanced: Custom Physics Plugin",id:"advanced-custom-physics-plugin",level:2},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"physics-simulation-fundamentals",children:"Physics Simulation Fundamentals"})}),"\n",(0,s.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(e.p,{children:"Physics simulation is the backbone of robot development, enabling testing and training without hardware. Understanding physics engines is crucial for creating realistic digital twins. This chapter covers the fundamentals of physics simulation for humanoid robots."}),"\n",(0,s.jsx)(e.h2,{id:"physics-engine-overview",children:"Physics Engine Overview"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mermaid",children:'graph TB\r\n    subgraph "Physics Engine"\r\n        COLLISION[Collision Detection]\r\n        DYNAMICS[Rigid Body Dynamics]\r\n        CONSTRAINTS[Constraints & Joints]\r\n        INTEGRATION[Numerical Integration]\r\n    end\r\n    \r\n    subgraph "Inputs"\r\n        URDF[Robot Model]\r\n        FORCES[Applied Forces]\r\n        TORQUES[Joint Torques]\r\n    end\r\n    \r\n    subgraph "Outputs"\r\n        POSITIONS[Link Positions]\r\n        VELOCITIES[Link Velocities]\r\n        CONTACTS[Contact Forces]\r\n    end\r\n    \r\n    URDF --\x3e COLLISION\r\n    FORCES --\x3e DYNAMICS\r\n    TORQUES --\x3e CONSTRAINTS\r\n    COLLISION --\x3e INTEGRATION\r\n    DYNAMICS --\x3e INTEGRATION\r\n    CONSTRAINTS --\x3e INTEGRATION\r\n    INTEGRATION --\x3e POSITIONS\r\n    INTEGRATION --\x3e VELOCITIES\r\n    INTEGRATION --\x3e CONTACTS\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"core-physics-concepts",children:"Core Physics Concepts"}),"\n",(0,s.jsx)(e.h3,{id:"1-rigid-body-dynamics",children:"1. Rigid Body Dynamics"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Newton's Second Law:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"F = ma  (Force = mass \xd7 acceleration)\r\n\u03c4 = I\u03b1  (Torque = inertia \xd7 angular acceleration)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Implementation in Gazebo:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom gazebo_msgs.srv import ApplyBodyWrench\r\nfrom geometry_msgs.msg import Wrench, Point\r\n\r\nclass PhysicsController(Node):\r\n    \"\"\"\r\n    Apply forces and torques to robot in simulation.\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        super().__init__('physics_controller')\r\n        \r\n        # Service client for applying forces\r\n        self.wrench_client = self.create_client(\r\n            ApplyBodyWrench,\r\n            '/gazebo/apply_body_wrench'\r\n        )\r\n        \r\n        self.get_logger().info('Physics Controller initialized')\r\n    \r\n    def apply_force(self, body_name, force, duration=1.0):\r\n        \"\"\"\r\n        Apply force to a link.\r\n        \r\n        Args:\r\n            body_name: Name of the link\r\n            force: Force vector [x, y, z] in Newtons\r\n            duration: Duration to apply force (seconds)\r\n        \"\"\"\r\n        request = ApplyBodyWrench.Request()\r\n        request.body_name = body_name\r\n        request.reference_frame = 'world'\r\n        \r\n        # Set force\r\n        request.wrench = Wrench()\r\n        request.wrench.force.x = force[0]\r\n        request.wrench.force.y = force[1]\r\n        request.wrench.force.z = force[2]\r\n        \r\n        # Set duration\r\n        request.duration.sec = int(duration)\r\n        request.duration.nanosec = int((duration % 1) * 1e9)\r\n        \r\n        # Apply\r\n        future = self.wrench_client.call_async(request)\r\n        rclpy.spin_until_future_complete(self, future)\r\n        \r\n        if future.result().success:\r\n            self.get_logger().info(f'Applied force to {body_name}')\r\n        else:\r\n            self.get_logger().error(f'Failed to apply force: {future.result().status_message}')\r\n    \r\n    def apply_torque(self, body_name, torque, duration=1.0):\r\n        \"\"\"\r\n        Apply torque to a link.\r\n        \r\n        Args:\r\n            body_name: Name of the link\r\n            torque: Torque vector [x, y, z] in Nm\r\n            duration: Duration (seconds)\r\n        \"\"\"\r\n        request = ApplyBodyWrench.Request()\r\n        request.body_name = body_name\r\n        request.reference_frame = 'world'\r\n        \r\n        # Set torque\r\n        request.wrench = Wrench()\r\n        request.wrench.torque.x = torque[0]\r\n        request.wrench.torque.y = torque[1]\r\n        request.wrench.torque.z = torque[2]\r\n        \r\n        request.duration.sec = int(duration)\r\n        request.duration.nanosec = int((duration % 1) * 1e9)\r\n        \r\n        future = self.wrench_client.call_async(request)\r\n        rclpy.spin_until_future_complete(self, future)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    controller = PhysicsController()\r\n    \r\n    # Example: Apply upward force to torso\r\n    controller.apply_force('torso', [0, 0, 100], duration=0.5)\r\n    \r\n    controller.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"2-collision-detection",children:"2. Collision Detection"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Collision Shapes:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Primitive:"})," Box, sphere, cylinder (fast)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mesh:"})," Complex geometry (slow but accurate)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Convex hull:"})," Simplified mesh (balanced)"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Configuring Collisions:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<link name="torso">\r\n  \x3c!-- Visual (what you see) --\x3e\r\n  <visual>\r\n    <geometry>\r\n      <mesh filename="package://robot_description/meshes/torso.dae"/>\r\n    </geometry>\r\n  </visual>\r\n  \r\n  \x3c!-- Collision (simplified for performance) --\x3e\r\n  <collision>\r\n    <geometry>\r\n      <box size="0.3 0.2 0.5"/>\r\n    </geometry>\r\n  </collision>\r\n</link>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Collision Filtering:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="left_foot">\r\n  <collision>\r\n    <surface>\r\n      <contact>\r\n        <collide_bitmask>0x01</collide_bitmask>\r\n      </contact>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\r\n\r\n<gazebo reference="right_foot">\r\n  <collision>\r\n    <surface>\r\n      <contact>\r\n        <collide_bitmask>0x01</collide_bitmask>\r\n      </contact>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\r\n\r\n\x3c!-- Prevent feet from colliding with each other --\x3e\r\n<gazebo>\r\n  <collision>\r\n    <surface>\r\n      <contact>\r\n        <collide_without_contact_bitmask>0x02</collide_without_contact_bitmask>\r\n      </contact>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"3-contact-dynamics",children:"3. Contact Dynamics"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Contact Parameters:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Friction:"})," Resistance to sliding"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Restitution:"})," Bounciness (0 = no bounce, 1 = perfect bounce)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Stiffness:"})," Contact spring constant"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Damping:"})," Contact damping"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Configuration:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="left_foot">\r\n  <collision>\r\n    <surface>\r\n      <friction>\r\n        <ode>\r\n          <mu>0.9</mu>   \x3c!-- Friction coefficient --\x3e\r\n          <mu2>0.9</mu2>\r\n        </ode>\r\n      </friction>\r\n      <contact>\r\n        <ode>\r\n          <kp>1000000.0</kp>  \x3c!-- Stiffness --\x3e\r\n          <kd>1.0</kd>         \x3c!-- Damping --\x3e\r\n          <max_vel>0.01</max_vel>\r\n          <min_depth>0.001</min_depth>\r\n        </ode>\r\n      </contact>\r\n      <bounce>\r\n        <restitution_coefficient>0.0</restitution_coefficient>\r\n      </bounce>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h3,{id:"4-numerical-integration",children:"4. Numerical Integration"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Common Methods:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Euler:"})," Simple, fast, unstable"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Runge-Kutta (RK4):"})," More accurate, slower"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Symplectic:"})," Energy-conserving"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Gazebo Configuration:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:"<physics type=\"ode\">\r\n  <max_step_size>0.001</max_step_size>  \x3c!-- 1ms timestep --\x3e\r\n  <real_time_factor>1.0</real_time_factor>\r\n  <real_time_update_rate>1000.0</real_time_update_rate>\r\n  \r\n  <ode>\r\n    <solver>\r\n      <type>quick</type>  \x3c!-- or 'world' for more accuracy --\x3e\r\n      <iters>50</iters>\r\n      <sor>1.3</sor>\r\n    </solver>\r\n    <constraints>\r\n      <cfm>0.0</cfm>\r\n      <erp>0.2</erp>\r\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n      <contact_surface_layer>0.001</contact_surface_layer>\r\n    </constraints>\r\n  </ode>\r\n</physics>\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"tuning-physics-for-stability",children:"Tuning Physics for Stability"}),"\n",(0,s.jsx)(e.h3,{id:"problem-robot-falls-through-floor",children:"Problem: Robot Falls Through Floor"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Causes:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Timestep too large"}),"\n",(0,s.jsx)(e.li,{children:"Contact stiffness too low"}),"\n",(0,s.jsx)(e.li,{children:"Collision mesh issues"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Solutions:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Reduce timestep --\x3e\r\n<max_step_size>0.0005</max_step_size>  \x3c!-- 0.5ms instead of 1ms --\x3e\r\n\r\n\x3c!-- Increase contact stiffness --\x3e\r\n<kp>10000000.0</kp>  \x3c!-- 10x higher --\x3e\r\n\r\n\x3c!-- Ensure proper collision geometry --\x3e\r\n<collision>\r\n  <geometry>\r\n    <box size="0.2 0.1 0.05"/>  \x3c!-- Proper size --\x3e\r\n  </geometry>\r\n</collision>\n'})}),"\n",(0,s.jsx)(e.h3,{id:"problem-simulation-too-slow",children:"Problem: Simulation Too Slow"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Causes:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Complex collision meshes"}),"\n",(0,s.jsx)(e.li,{children:"Too many contacts"}),"\n",(0,s.jsx)(e.li,{children:"Small timestep"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Solutions:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Simplify collision geometry --\x3e\r\n<collision>\r\n  <geometry>\r\n    <box size="..."/>  \x3c!-- Use primitives instead of meshes --\x3e\r\n  </geometry>\r\n</collision>\r\n\r\n\x3c!-- Increase timestep (carefully) --\x3e\r\n<max_step_size>0.002</max_step_size>\r\n\r\n\x3c!-- Reduce solver iterations --\x3e\r\n<iters>20</iters>  \x3c!-- Instead of 50 --\x3e\n'})}),"\n",(0,s.jsx)(e.h3,{id:"problem-robot-unstablejittery",children:"Problem: Robot Unstable/Jittery"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Causes:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Joint damping too low"}),"\n",(0,s.jsx)(e.li,{children:"Contact parameters not tuned"}),"\n",(0,s.jsx)(e.li,{children:"Numerical instability"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Solutions:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Increase joint damping --\x3e\r\n<joint name="knee_joint">\r\n  <dynamics damping="1.0" friction="0.1"/>  \x3c!-- Higher damping --\x3e\r\n</joint>\r\n\r\n\x3c!-- Tune contact parameters --\x3e\r\n<kd>10.0</kd>  \x3c!-- Higher damping --\x3e\r\n<erp>0.2</erp>  \x3c!-- Error reduction parameter --\x3e\n'})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"physics-engine-comparison",children:"Physics Engine Comparison"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Engine"}),(0,s.jsx)(e.th,{children:"Simulator"}),(0,s.jsx)(e.th,{children:"Speed"}),(0,s.jsx)(e.th,{children:"Accuracy"}),(0,s.jsx)(e.th,{children:"Features"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ODE"})}),(0,s.jsx)(e.td,{children:"Gazebo Classic"}),(0,s.jsx)(e.td,{children:"Fast"}),(0,s.jsx)(e.td,{children:"Medium"}),(0,s.jsx)(e.td,{children:"Good for rigid bodies"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Bullet"})}),(0,s.jsx)(e.td,{children:"Gazebo, PyBullet"}),(0,s.jsx)(e.td,{children:"Fast"}),(0,s.jsx)(e.td,{children:"Medium"}),(0,s.jsx)(e.td,{children:"Soft bodies, cloth"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"DART"})}),(0,s.jsx)(e.td,{children:"Gazebo"}),(0,s.jsx)(e.td,{children:"Medium"}),(0,s.jsx)(e.td,{children:"High"}),(0,s.jsx)(e.td,{children:"Precise contact"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"PhysX"})}),(0,s.jsx)(e.td,{children:"Isaac Sim"}),(0,s.jsx)(e.td,{children:"Very Fast"}),(0,s.jsx)(e.td,{children:"High"}),(0,s.jsx)(e.td,{children:"GPU acceleration"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"MuJoCo"})}),(0,s.jsx)(e.td,{children:"MuJoCo"}),(0,s.jsx)(e.td,{children:"Fast"}),(0,s.jsx)(e.td,{children:"Very High"}),(0,s.jsx)(e.td,{children:"Optimal control"})]})]})]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"advanced-custom-physics-plugin",children:"Advanced: Custom Physics Plugin"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:"// Gazebo plugin for custom physics\r\n#include <gazebo/gazebo.hh>\r\n#include <gazebo/physics/physics.hh>\r\n\r\nnamespace gazebo\r\n{\r\n  class CustomPhysicsPlugin : public WorldPlugin\r\n  {\r\n    public: void Load(physics::WorldPtr _world, sdf::ElementPtr _sdf)\r\n    {\r\n      // Get physics engine\r\n      this->world = _world;\r\n      this->physics = _world->Physics();\r\n      \r\n      // Set custom parameters\r\n      this->physics->SetGravity(ignition::math::Vector3d(0, 0, -9.81));\r\n      \r\n      // Connect to update event\r\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\r\n        std::bind(&CustomPhysicsPlugin::OnUpdate, this));\r\n    }\r\n    \r\n    private: void OnUpdate()\r\n    {\r\n      // Custom physics logic every timestep\r\n      // E.g., apply custom forces, modify contacts, etc.\r\n    }\r\n    \r\n    private: physics::WorldPtr world;\r\n    private: physics::PhysicsEnginePtr physics;\r\n    private: event::ConnectionPtr updateConnection;\r\n  };\r\n  \r\n  GZ_REGISTER_WORLD_PLUGIN(CustomPhysicsPlugin)\r\n}\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Rigid body dynamics:"})," F=ma, \u03c4=I\u03b1"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision detection:"})," Primitive shapes for performance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Contact dynamics:"})," Friction, restitution, stiffness"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Numerical integration:"})," Timestep crucial for stability"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tuning:"})," Balance accuracy vs. speed"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Engine choice:"})," Depends on application needs"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Understanding physics simulation fundamentals enables creating realistic digital twins for effective robot development."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"http://gazebosim.org/tutorials?cat=physics",children:"Gazebo Physics"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://www.ode.org/",children:"ODE Documentation"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://pybullet.org/",children:"Bullet Physics"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://mujoco.readthedocs.io/",children:"MuJoCo Documentation"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function o(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);