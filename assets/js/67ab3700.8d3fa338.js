"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[5529],{6486:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"The-Digital-Twin/Domain-Randomization/domain-randomization","title":"Domain Randomization Techniques","description":"Introduction","source":"@site/docs/03-The-Digital-Twin/05-Domain-Randomization/index.md","sourceDirName":"03-The-Digital-Twin/05-Domain-Randomization","slug":"/module-03/domain-randomization","permalink":"/physical-ai-hackathon/docs/module-03/domain-randomization","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-The-Digital-Twin/05-Domain-Randomization/index.md","tags":[],"version":"current","frontMatter":{"id":"domain-randomization","title":"Domain Randomization Techniques","slug":"/module-03/domain-randomization"},"sidebar":"tutorialSidebar","previous":{"title":"Physics Simulation Fundamentals","permalink":"/physical-ai-hackathon/docs/module-03/physics-simulation-fundamentals"},"next":{"title":"Sim-to-Real Transfer","permalink":"/physical-ai-hackathon/docs/module-03/sim-to-real-transfer"}}');var a=r(4848),s=r(8453);const o={id:"domain-randomization",title:"Domain Randomization Techniques",slug:"/module-03/domain-randomization"},t="Domain Randomization Techniques",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Core Concept",id:"core-concept",level:2},{value:"What to Randomize",id:"what-to-randomize",level:2},{value:"1. Physics Parameters",id:"1-physics-parameters",level:3},{value:"2. Visual Appearance",id:"2-visual-appearance",level:3},{value:"3. Sensor Noise",id:"3-sensor-noise",level:3},{value:"Complete Domain Randomization System",id:"complete-domain-randomization-system",level:2},{value:"Automatic Domain Randomization (ADR)",id:"automatic-domain-randomization-adr",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 DO:",id:"-do",level:3},{value:"\u274c DON&#39;T:",id:"-dont",level:3},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function m(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"domain-randomization-techniques",children:"Domain Randomization Techniques"})}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Domain Randomization"})," is a technique to train robust policies by exposing them to a wide variety of simulated conditions. By randomizing physics parameters, visual appearance, and sensor noise, policies learn to handle the variability of the real world."]}),"\n",(0,a.jsx)(e.h2,{id:"core-concept",children:"Core Concept"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-mermaid",children:'graph LR\r\n    subgraph "Traditional Training"\r\n        FIXED[Fixed Simulation] --\x3e POLICY1[Brittle Policy]\r\n        POLICY1 -.Fails.-> REAL1[Real World]\r\n    end\r\n    \r\n    subgraph "Domain Randomization"\r\n        RANDOM[Randomized Simulations] --\x3e POLICY2[Robust Policy]\r\n        POLICY2 -.Succeeds.-> REAL2[Real World]\r\n    end\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Key Insight:"})," If a policy works across many randomized simulations, it's likely to work in the real world (which is just one more variation)."]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"what-to-randomize",children:"What to Randomize"}),"\n",(0,a.jsx)(e.h3,{id:"1-physics-parameters",children:"1. Physics Parameters"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import random\r\nimport numpy as np\r\n\r\nclass PhysicsRandomizer:\r\n    \"\"\"\r\n    Randomizes physics parameters in simulation.\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # Randomization ranges\r\n        self.ranges = {\r\n            'gravity': (9.5, 10.2),\r\n            'friction': (0.5, 1.5),\r\n            'mass_scale': (0.9, 1.1),\r\n            'joint_damping_scale': (0.8, 1.2),\r\n            'timestep': (0.0008, 0.0012)\r\n        }\r\n    \r\n    def randomize_all(self):\r\n        \"\"\"Randomize all physics parameters\"\"\"\r\n        params = {}\r\n        \r\n        for param, (min_val, max_val) in self.ranges.items():\r\n            params[param] = random.uniform(min_val, max_val)\r\n        \r\n        return params\r\n    \r\n    def apply_to_gazebo(self, params):\r\n        \"\"\"Apply randomized parameters to Gazebo\"\"\"\r\n        # Set gravity\r\n        self.set_gravity(params['gravity'])\r\n        \r\n        # Scale all link masses\r\n        self.scale_masses(params['mass_scale'])\r\n        \r\n        # Scale joint damping\r\n        self.scale_joint_damping(params['joint_damping_scale'])\r\n        \r\n        # Set friction for all surfaces\r\n        self.set_friction(params['friction'])\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-visual-appearance",children:"2. Visual Appearance"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class VisualRandomizer:\r\n    """\r\n    Randomizes visual appearance of objects and environment.\r\n    """\r\n    \r\n    def randomize_colors(self):\r\n        """Randomize object colors"""\r\n        for obj in self.scene_objects:\r\n            # Random RGB\r\n            r = random.uniform(0, 1)\r\n            g = random.uniform(0, 1)\r\n            b = random.uniform(0, 1)\r\n            \r\n            self.set_object_color(obj, (r, g, b, 1.0))\r\n    \r\n    def randomize_textures(self):\r\n        """Randomize surface textures"""\r\n        texture_library = [\r\n            \'wood\', \'metal\', \'plastic\', \'concrete\', \'carpet\'\r\n        ]\r\n        \r\n        for surface in self.surfaces:\r\n            texture = random.choice(texture_library)\r\n            self.set_surface_texture(surface, texture)\r\n    \r\n    def randomize_lighting(self):\r\n        """Randomize lighting conditions"""\r\n        # Ambient light intensity\r\n        ambient = random.uniform(0.3, 0.8)\r\n        self.set_ambient_light(ambient)\r\n        \r\n        # Directional light angle\r\n        azimuth = random.uniform(0, 2*np.pi)\r\n        elevation = random.uniform(0, np.pi/2)\r\n        self.set_sun_angle(azimuth, elevation)\r\n        \r\n        # Light color temperature\r\n        temp = random.uniform(3000, 6500)  # Kelvin\r\n        self.set_light_temperature(temp)\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-sensor-noise",children:"3. Sensor Noise"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class SensorRandomizer:\r\n    """\r\n    Adds realistic noise to sensor data.\r\n    """\r\n    \r\n    def randomize_camera(self, image):\r\n        """Add camera noise"""\r\n        # Gaussian noise\r\n        noise = np.random.normal(0, 5, image.shape)\r\n        noisy_image = np.clip(image + noise, 0, 255)\r\n        \r\n        # Random exposure\r\n        exposure = random.uniform(0.8, 1.2)\r\n        noisy_image = np.clip(noisy_image * exposure, 0, 255)\r\n        \r\n        # Random blur\r\n        if random.random() < 0.3:\r\n            kernel_size = random.choice([3, 5])\r\n            noisy_image = cv2.GaussianBlur(noisy_image, (kernel_size, kernel_size), 0)\r\n        \r\n        return noisy_image.astype(np.uint8)\r\n    \r\n    def randomize_imu(self, imu_data):\r\n        """Add IMU noise"""\r\n        # Gyroscope noise (rad/s)\r\n        gyro_noise = np.random.normal(0, 0.01, 3)\r\n        imu_data[\'angular_velocity\'] += gyro_noise\r\n        \r\n        # Accelerometer noise (m/s\xb2)\r\n        accel_noise = np.random.normal(0, 0.1, 3)\r\n        imu_data[\'linear_acceleration\'] += accel_noise\r\n        \r\n        # Random bias drift\r\n        if random.random() < 0.1:\r\n            bias = np.random.normal(0, 0.005, 3)\r\n            imu_data[\'angular_velocity\'] += bias\r\n        \r\n        return imu_data\r\n    \r\n    def randomize_lidar(self, ranges):\r\n        """Add LiDAR noise"""\r\n        # Gaussian noise on ranges\r\n        noise = np.random.normal(0, 0.01, len(ranges))\r\n        noisy_ranges = ranges + noise\r\n        \r\n        # Random dropouts\r\n        dropout_prob = 0.05\r\n        dropout_mask = np.random.random(len(ranges)) > dropout_prob\r\n        noisy_ranges = noisy_ranges * dropout_mask\r\n        \r\n        # Clip to valid range\r\n        noisy_ranges = np.clip(noisy_ranges, 0.1, 30.0)\r\n        \r\n        return noisy_ranges\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"complete-domain-randomization-system",children:"Complete Domain Randomization System"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nComplete domain randomization system for training robust policies.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom gazebo_msgs.srv import SetPhysicsProperties, SetModelState\r\nimport random\r\nimport numpy as np\r\n\r\nclass DomainRandomizationManager(Node):\r\n    """\r\n    Manages all aspects of domain randomization.\r\n    """\r\n    \r\n    def __init__(self):\r\n        super().__init__(\'domain_randomization_manager\')\r\n        \r\n        # Randomizers\r\n        self.physics_randomizer = PhysicsRandomizer()\r\n        self.visual_randomizer = VisualRandomizer()\r\n        self.sensor_randomizer = SensorRandomizer()\r\n        \r\n        # Randomization schedule\r\n        self.declare_parameter(\'randomize_every_n_episodes\', 1)\r\n        self.randomize_interval = self.get_parameter(\'randomize_every_n_episodes\').value\r\n        \r\n        self.episode_count = 0\r\n        \r\n        # Service clients\r\n        self.setup_service_clients()\r\n        \r\n        self.get_logger().info(\'Domain Randomization Manager initialized\')\r\n    \r\n    def setup_service_clients(self):\r\n        """Setup Gazebo service clients"""\r\n        self.physics_client = self.create_client(\r\n            SetPhysicsProperties,\r\n            \'/gazebo/set_physics_properties\'\r\n        )\r\n        \r\n        self.model_state_client = self.create_client(\r\n            SetModelState,\r\n            \'/gazebo/set_model_state\'\r\n        )\r\n    \r\n    def on_episode_start(self):\r\n        """Called at the start of each training episode"""\r\n        self.episode_count += 1\r\n        \r\n        if self.episode_count % self.randomize_interval == 0:\r\n            self.randomize_environment()\r\n    \r\n    def randomize_environment(self):\r\n        """Randomize all aspects of the environment"""\r\n        self.get_logger().info(f\'Randomizing environment (episode {self.episode_count})\')\r\n        \r\n        # 1. Randomize physics\r\n        physics_params = self.physics_randomizer.randomize_all()\r\n        self.apply_physics_params(physics_params)\r\n        \r\n        # 2. Randomize visual appearance\r\n        self.visual_randomizer.randomize_colors()\r\n        self.visual_randomizer.randomize_textures()\r\n        self.visual_randomizer.randomize_lighting()\r\n        \r\n        # 3. Randomize object positions\r\n        self.randomize_object_positions()\r\n        \r\n        # 4. Randomize robot initial state\r\n        self.randomize_robot_state()\r\n        \r\n        self.get_logger().info(\'Environment randomization complete\')\r\n    \r\n    def apply_physics_params(self, params):\r\n        """Apply physics parameters to Gazebo"""\r\n        request = SetPhysicsProperties.Request()\r\n        \r\n        # Set gravity\r\n        request.gravity.z = -params[\'gravity\']\r\n        \r\n        # Set timestep\r\n        request.time_step = params[\'timestep\']\r\n        \r\n        # Set solver parameters\r\n        request.max_update_rate = 1000.0\r\n        \r\n        # Call service\r\n        future = self.physics_client.call_async(request)\r\n        rclpy.spin_until_future_complete(self, future)\r\n        \r\n        if future.result().success:\r\n            self.get_logger().info(f\'Applied physics params: {params}\')\r\n    \r\n    def randomize_object_positions(self):\r\n        """Randomize positions of objects in scene"""\r\n        objects = [\'box_1\', \'box_2\', \'cylinder_1\']\r\n        \r\n        for obj_name in objects:\r\n            # Random position within bounds\r\n            x = random.uniform(-2.0, 2.0)\r\n            y = random.uniform(-2.0, 2.0)\r\n            z = random.uniform(0.5, 1.5)\r\n            \r\n            # Random orientation\r\n            yaw = random.uniform(0, 2*np.pi)\r\n            \r\n            self.set_model_pose(obj_name, x, y, z, 0, 0, yaw)\r\n    \r\n    def randomize_robot_state(self):\r\n        """Randomize robot\'s initial state"""\r\n        # Random position\r\n        x = random.uniform(-0.5, 0.5)\r\n        y = random.uniform(-0.5, 0.5)\r\n        \r\n        # Random orientation\r\n        yaw = random.uniform(-np.pi/4, np.pi/4)\r\n        \r\n        self.set_model_pose(\'humanoid_robot\', x, y, 1.0, 0, 0, yaw)\r\n    \r\n    def set_model_pose(self, model_name, x, y, z, roll, pitch, yaw):\r\n        """Set model pose in Gazebo"""\r\n        request = SetModelState.Request()\r\n        request.model_state.model_name = model_name\r\n        \r\n        # Position\r\n        request.model_state.pose.position.x = x\r\n        request.model_state.pose.position.y = y\r\n        request.model_state.pose.position.z = z\r\n        \r\n        # Orientation (convert RPY to quaternion)\r\n        from scipy.spatial.transform import Rotation\r\n        quat = Rotation.from_euler(\'xyz\', [roll, pitch, yaw]).as_quat()\r\n        request.model_state.pose.orientation.x = quat[0]\r\n        request.model_state.pose.orientation.y = quat[1]\r\n        request.model_state.pose.orientation.z = quat[2]\r\n        request.model_state.pose.orientation.w = quat[3]\r\n        \r\n        # Call service\r\n        future = self.model_state_client.call_async(request)\r\n        rclpy.spin_until_future_complete(self, future)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    manager = DomainRandomizationManager()\r\n    \r\n    # Simulate training loop\r\n    for episode in range(100):\r\n        manager.on_episode_start()\r\n        # ... training code ...\r\n        time.sleep(1)  # Simulate episode\r\n    \r\n    manager.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"automatic-domain-randomization-adr",children:"Automatic Domain Randomization (ADR)"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Concept:"})," Automatically adjust randomization ranges based on policy performance."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class AutomaticDomainRandomization:\r\n    \"\"\"\r\n    Automatically adjusts randomization ranges.\r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        # Initial ranges\r\n        self.ranges = {\r\n            'gravity': {'min': 9.8, 'max': 9.8, 'delta': 0.1},\r\n            'friction': {'min': 0.8, 'max': 0.8, 'delta': 0.1},\r\n        }\r\n        \r\n        # Performance threshold\r\n        self.success_threshold = 0.9\r\n        \r\n        # History\r\n        self.performance_history = []\r\n    \r\n    def update_ranges(self, success_rate):\r\n        \"\"\"\r\n        Update randomization ranges based on performance.\r\n        \r\n        Args:\r\n            success_rate: Success rate in current randomization range\r\n        \"\"\"\r\n        if success_rate > self.success_threshold:\r\n            # Policy is doing well, increase randomization\r\n            for param in self.ranges:\r\n                self.ranges[param]['min'] -= self.ranges[param]['delta']\r\n                self.ranges[param]['max'] += self.ranges[param]['delta']\r\n            \r\n            self.get_logger().info('Increased randomization ranges')\r\n        else:\r\n            # Policy struggling, decrease randomization\r\n            for param in self.ranges:\r\n                self.ranges[param]['min'] += self.ranges[param]['delta'] / 2\r\n                self.ranges[param]['max'] -= self.ranges[param]['delta'] / 2\r\n            \r\n            self.get_logger().info('Decreased randomization ranges')\n"})}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"-do",children:"\u2705 DO:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Start Conservative"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Begin with small randomization ranges"}),"\n",(0,a.jsx)(e.li,{children:"Gradually increase as policy improves"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Randomize What Matters"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Focus on parameters that vary in reality"}),"\n",(0,a.jsx)(e.li,{children:"Don't randomize everything blindly"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Monitor Performance"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Track success rate vs. randomization level"}),"\n",(0,a.jsx)(e.li,{children:"Use ADR for automatic tuning"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Test Systematically"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Ablation studies to find important parameters"}),"\n",(0,a.jsx)(e.li,{children:"Measure sim-to-real gap"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"-dont",children:"\u274c DON'T:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Don't Over-Randomize"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Too much randomization makes learning impossible"}),"\n",(0,a.jsx)(e.li,{children:"Policy may become overly conservative"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Don't Ignore Correlations"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Some parameters are correlated (e.g., mass and friction)"}),"\n",(0,a.jsx)(e.li,{children:"Randomize them together"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Don't Forget Validation"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Always validate on real robot"}),"\n",(0,a.jsx)(e.li,{children:"Simulation is not reality"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Domain randomization"})," trains robust policies"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Randomize:"})," Physics, visuals, sensors, initial conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"ADR:"})," Automatically adjusts ranges based on performance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance:"})," Too little = brittle, too much = can't learn"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validate:"})," Always test on real hardware"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Domain randomization is a powerful technique for bridging the sim-to-real gap."}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://arxiv.org/abs/1703.06907",children:"Domain Randomization for Transferring Deep Neural Networks"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://arxiv.org/abs/1910.07113",children:"Automatic Domain Randomization"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://arxiv.org/abs/1812.07252",children:"Sim-to-Real Transfer in Robotics"})}),"\n"]})]})}function c(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(m,{...n})}):m(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>t});var i=r(6540);const a={},s=i.createContext(a);function o(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);